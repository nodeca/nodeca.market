// Show edit history
//

'use strict';


const _                   = require('lodash');
const sanitize_section    = require('nodeca.market/lib/sanitizers/section');


module.exports = function (N, apiPath) {

  N.validate(apiPath, {
    item_id: { format: 'mongo', required: true }
  });


  // Check permissions
  //
  N.wire.before(apiPath, async function check_permissions(env) {
    let can_see_history = await env.extras.settings.fetch('can_see_history');

    if (!can_see_history) throw N.io.FORBIDDEN;
  });


  // Fetch item
  //
  N.wire.before(apiPath, async function fetch_item(env) {
    env.data.item = await N.models.market.ItemOffer
                              .findById(env.params.item_id)
                              .lean(true);

    if (!env.data.item) {
      env.data.item = await N.models.market.ItemOfferArchived
                                .findById(env.params.item_id)
                                .lean(true);
    }

    if (!env.data.item) throw N.io.NOT_FOUND;
  });


  // Check if user can see this item
  //
  N.wire.before(apiPath, async function check_access(env) {
    let access_env = { params: {
      items: env.data.item,
      user_info: env.user_info
    } };

    await N.wire.emit('internal:market.access.item_offer', access_env);

    if (!access_env.data.access_read) throw N.io.NOT_FOUND;
  });


  // Using different sanitizer here,
  // because we need to expose editable fields (md) and don't need
  // autogenerated ones (bookmarks, views, html)
  //
  function sanitize_item(item) {
    // we can always hide HB status, because it doesn't affect client diffs
    if (item.st === N.models.market.ItemOffer.statuses.HB) {
      item = Object.assign({}, item);
      item.st = item.ste;
      delete item.ste;
    }

    if (item.prev_st && item.prev_st.st === N.models.market.ItemOffer.statuses.HB) {
      item.prev_st = Object.assign({}, item.prev_st);
      item.prev_st.st = item.prev_st.ste;
      delete item.prev_st.ste;
    }

    return _.pick(item, [
      'section',
      'title',
      'price',
      'md',
      'barter_info',
      'delivery',
      'is_new',
      'st',
      'ste',
      'del_reason',
      'del_by',
      'autoclose_at_ts',
      'prev_st',
      'location',
      'files'
    ]);
  }


  // Fetch and return item edit history
  //
  N.wire.on(apiPath, async function get_item_history(env) {
    let history = await N.models.market.ItemOfferHistory.find()
                            .where('item').equals(env.data.item._id)
                            .sort('_id')
                            .lean(true);

    let history_meta = [ {
      user: env.data.item.user,
      ts:   env.data.item.ts,
      role: N.models.market.ItemOfferHistory.roles.USER
    } ].concat(
      _.map(history, i => ({ user: i.user, ts: i.ts, role: i.role }))
    );

    let history_items = _.map(history, 'item_data')
                         .concat([ env.data.item ])
                         .map(sanitize_item);

    env.res.history = _.zip(history_meta, history_items)
                       .map(([ meta, item ]) => ({ meta, item }));

    env.data.users = (env.data.users || []).concat(_.map(env.res.history, 'meta.user'));
  });


  // Fetch sections
  //
  N.wire.after(apiPath, async function fetch_sections(env) {
    let sections = [];
    let section_ids = _.uniq(_.map(env.res.history, 'item.section').filter(Boolean).map(String));

    if (section_ids) {
      sections = await N.models.market.Section.find()
                           .where('_id').in(section_ids)
                           .lean(true);
    }

    env.res.sections = _.keyBy(await sanitize_section(N, sections, env.user_info), '_id');
  });


  // Fetch locations
  //
  N.wire.after(apiPath, async function fetch_locations(env) {
    let locations = _.map(env.res.history_data, 'item.location').filter(Boolean);

    let resolved = locations.length ?
                   await N.models.core.Location.info(locations, env.user_info.locale) :
                   [];

    env.res.location_names = {};

    for (let i = 0; i < locations.length; i++) {
      env.res.location_names[locations[i][0] + ':' + locations[i][1]] = resolved[i];
    }
  });
};
